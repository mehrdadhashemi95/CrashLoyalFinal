Design Goals of the AI:

   Initially, I set my goals to be making an AI that would be almost impossible for myself to defeat. I have played Clash Royale before and I have got to high Arenas, so at first my list of desired features included things that weren’t too necessary, such as calculating the best dropping location on the map. Since this version of the game was simpler than the original version, I had to tweak my list a bit and focus on more precious goals. Gradually I found that the most important thing for the AI to focus on is to know when to act offensively and when to act defensively. So I implemented my ideas in the following way. If the Prince towers are under attack (they are losing health), or if there is an enemy Giant on the map the AI was supposed to act defensively and when there is no threat on the map, release the Giant and send enough support. 

  Although the implementation of this design was as I expected, as I played against the AI personally I realized that it is easily beatable. I could simply wait for the AI to attack and with proper picking of my mobs I could stop the AI’s attack decently. Meanwhile, the AI was getting worn out on the Exilir after its offensives, resulting in its inability to defend its towers in my counter attacks. In order to solve this issue I decided to change the Interface of my Controller, and give the AI information about the enemy mobs on the map. Archers are easily killable by Swordsman, the AI only needs to be careful to place its mob close to the enemy mob so that it wouldn’t focus on the wrong target. For example, there was cases that the AI’s swordsman would go for my giant instead of my supporting archers. So my archers could freely do their heavy damage.

   Besides, I found out that instead of having different strategies for the left wing and right wing attacks its best if the AI could decide itself, weather left or right side of the map is the best location to drop the mobs, so I initially added a decider class, but later incorporated it into the Controller interface as a function that would pick the X variable of the mobs we place. The Y variable is usually the same for the mobs of the same kind. The decider function considers the health of the enemy prince towers and picks the side of the map that is closer to the most vulnerable (the one with the lowest health) of the two. The Implementation worked successfully, but I was intending to give the AI the ability to change this strategy after one of the enemy’s prince towers has fallen. Because, sometimes it is best to attack the enemy’s King tower instead of trying to take the other Prince tower.

Description of structure/ architecture & Decision-making Process:

   Initially for design purposes, I put together all the “mob placings” into a Strategy class. Basically the Controller class would look at (A) how much Elixir the player has, (B) how much life the Enemy Prince towers have left, and (C) if the enemy is in offensive with a giant, and based on these factors the Controller class would pick the right instance of the Strategy class to make and run its execute function that is responsible for placing the mobs. For reasons that I couldn’t figure out, Visual Studio was not recognizing some of the Game and Player functions inside my Strategy class. This caused a lot of headache for me, and finally I had to move everything into one Controller_AI class, which did look ugly but at least worked very well.

  The final design has the basic skeleton of the decision making being done inside the Tick function of the Controller Class. Every strategy has a “code of attack”, inside the Controller Class this is marked by an integer “code”. It is initialized to 3 for an offensive attack, and every time a strategy runs, it updates the code of attack. The negative codes are defensive and the positive codes are the offensive attacks. After heavily Elixir-consuming strategies such as placing 3 swordsman, or a giant and 2 archers (both costing 9 Elixir) the AI checks to make sure its Prince towers wouldn’t be under attack. If they were it would change the “code” to the appropriate defensive code. Besides, the AI can also change the code of attack according to the kind of enemy mob. This is done through the three function of findEnemyGiant(), findEnemyArcher(), and findEnemySword() which are inside the Controller interface and put into use inside the Tick function as the AI decides which strategy to take.

Stretch Goals:

  I started this project with a lot of unnecessary attention to the importance of the drop location of mobs on the map. But, as I changed the design and eliminated these details, I put my Stretch Goal to be making an AI that is capable of testing and learning. I was hoping to have my AI place its mobs against enemy mobs in different distances and different kinds of mobs to find out the best strategy. Of course I never had the chance to implement such machine learning behavior, but I was intending to do so by giving the AI a few parameter to measure its success with. This parameter can’t be winning the game, but knowing how much time it took to kill the enemy mob was my starting target. 

